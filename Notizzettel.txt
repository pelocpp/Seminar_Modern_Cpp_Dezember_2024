==================================

Modern C++

Peter Loos

Guten Morgen

==================================

C++/C (Pascal), Java, C#,  Android (Java), JavaScript

Back-to-the-Roots: C++

==================================

2 Tools: 

a) Visual Studio 2022 - Community Version

b) Unterlagen:

   https://github.com/pelocpp

==================================

Mo - Do:

9.00 bis 17.00 Uhr

Mittagspause: 12.30 

== Übungen

== 16.30 / 16.45

==================================

Was sind meine Erwartungen

== Überblick
== Muss ab nächster Woche C++ "modern" programmieren
== Verständnis für die neuen Techniken
== Was MUSS drin sein
== Will C++ Quellcode nur lesen / verstehen können

Hintergrund / "Confidence"

Welche Aspekte sind wann nützlich?

C++ ist eine schwierige Programmiersprache.

==================================

To be Done:

noexcept    // Exception Safety

emplace

delegate: C#

Callable // ähnlich zu delegate

==================================


C++:   "Roter Faden"   // Struktur

==>   Agenda

==================================

Verschiebe-Semantik (Move-Semantik)

== RValue / LValue
== Verschiebe-Semantik

Parameter-Übergabe:

i)  Kopie  -  nicht performant
ii) Adresse eines Objekts

sayHello(a + b);

 a + b ist wie a ein normales std::string Objekt

 a kann ich unter dem Namen "a" ansprechen

 a + b ist ein temporäres Objekt

 std::string tmp =  a + b;

 Performanz: C++ 11  

 Übergabe temporärer Objekte mit Adresse / keine Kopie !!!


 std::string&:      LValue - Referenz
 std::string&&:     RValue - Referenz

 Why ?????????????? ===> Move-Semantik

         Namensgebung: LValue stammt von C  // Left Value

                       " a = b; "  a steht links vom dem = Zeichen

                                   Interesse: Adresse

                                   RValue   // Wert

                                   b steht rechts vom dem = Zeichen

                                   Interesse: Wert

====================================================================

Move-Semantik:

... E60:   // tmp. Objekt  // wird freigegeben
... D10:   // Objekt im Vektor

Neu:

... 100:

====================================================================

Refresher:

== Kopier-Konstruktor
== Wertzuweisungs-Operator (operator =)

BigData bd;

BigData bd1 = bd;

a) Ja, geht / übersetzungsfähig !!!

b) Wie ???  Es werden alle Variablen 1:1 umkopiert - auch Adressen !!!

      Flache Kopie // Shallow Copy

    Wenn diese nicht das tut, was notwendig ist:

    Kopier-Konstruktor ergänzen:

    BigData

    BigData (const BigData& original); 

https://github.com/pelocpp/cpp_introduction/blob/master/Cpp_Introduction/Markdown/RuleOfThree.md

==> 2 Probleme:

i ) Keine "echte" Kopie ==> Heap-Speicher

ii) "doppelte delete"  ===> 

===============================================================

std::map <std::string, long>  // Definition

Zugriff // Ein Element auf der Map rausholen wollen:

   std::pair<const std::string, long>

Ist eine Tabelle aus 

Schlüssel / Wert-Paaren:

Beispiel:

Telefonbuch:

Schlüssel (Key): "Hans"
Wert (Value):    1231312 // 45645645

std::map<std::string, long>

Jedes einzelne Element:    std::pair<const std::string, long>

==========================================

    static auto sum(float f1, float f2)
    {
        return f1 + f2;
    }


// old, "classical" syntax
std::string toString(int value);

// new syntax with trailing return type
auto toString(int value) -> std::string;


Why ??????????????????
???????????????????????????

C++:
  == strongly-typed
  == objekt-orientiert

  == GP 
  == generic programming (templates)

Inventor:  Bjarne Stroustrup  (C with Classes)

Alexander Alexandrowitsch Stepanow: Generische Programierung (Templates)

Bibliothek für C++:  STL  Standard Template Library

Generische Programierung

Metaprogramming:  Programmierung zur Übersetzungszeit.

====================================================

    static const std::string& getMessage()
    {
        std::string result("efwerwer");  // Lokales Objekt

        return result;
    }

    ERROR: returning address of local variable or temporary : result


class Contact
{
private:
    std::string m_phoneHome;
    std::string m_phoneOffice;

public:
    const std::string& getPhoneOffice ( return m_phoneOffice);
}

======================================================

Initialisierung:  ( )  versus { }

Jein :)

======================================================

Lambdas:

a) Erklären  // zahlreiche Features

b) Blick hinter die Kulissen

Lambda-Objekte

Wie ist es zu Lambdas gekommen ???

Aufrufbares Objekt

operator()

operator+:   2 Operanden

Wie wird in C++ eine Lambda-Funkion vom Compiler gesehen // umgesetzt:

Als Instanz einer lokalen Klasse (versteckt),
die den operator() implementiert.

"Woher weißt da das ???"

Tool  : Empfehlung

Cpp Insights:

Es ist eine Art "C++ nach C++" Konverter,
um von "modernem" C++ eine Darstellung zu bekommen,
wie der Compiler / wie die Sprache C++ moderne in vorhandene Konstrukte umsetzt.


std::sort(vec.begin(), vec.end(), __lambda_11_13{});

Hier sieht man:  Ein Lambda ist ein Objekt.

Feature 1: Zugriff auf Variablen "außerhalb"

Feature 2: Lambdas sind Objekte.

   Was haben Objekte: Member-Variablen.


JavaScript // C++:

Lokale Variablen, die in einem Lambda verwendet werden:

Closure  ===> (JavaScript) :  HEAP


Letzte Frage:

Von welchem Typ ist ein Lambda-Objekt:

i)  Vom Typ der anonymen Klasse

ii) std::function<>

=====================================================

auto: 

a) Vereinbarung von Variablen

b) Rückgabetyp von Funktionen

c) Als Typ von Parametern


=====================================================

Aufgaben:

Aufgaben zur Move-Semantik:

    Aufgabe 1


Aufgaben zu Lambda:

    Aufgabe 1

    Aufgabe 3:  Quiz 1und  Quiz 2 sind einfach.

    3 und 4 sind Stolperfallen.

Aufgaben zu generische Lambda Funktionen:

    Aufgabe 1


Wann kann ich die no-throw Garantie geben ????

In Methoden, die nur aus Wertzuweisungen bestehen.

a) Getter / setter:

   Vorsicht: Hier würde ich kein noexcept verwenden.

b) Doch, doch: In vielen "anspruchsvollen" C++ Quellen findet man noexcept vor.

Vorteil von noexcept:

void tueWas1 () noexcept // KEIN Stack Unwinding Code abgesetzt !!!!!!!
                         // Runtime: terminate
{
    int* ip = new int[100];   // std::bad_alloc

    // std::bad_alloc wird an die aufrufende Methode (am Stack) weitergereicht

    // Stack Unwinding Code
}

void tueWas2 ()
{
    try {
        int* ip = new int[100];   // std::bad_alloc
    }
    catch (std::bad_alloc) {
    
        // 
    }
}


void rufeTueWasAuf ()
{
    try {
        tueWas1 ();
    }
    catch (std::bad_alloc) {
    
        // 
    }
}

==========================================================

Konstanten // Literale

123

123.456

123.456f

123ul

123ll

Frage:


123_kg

123_kilometer

123_km                // elementare Datentypen

123_pound

123_euros

0xFF0000_farbe

0xFF0000_rgb     // ben. def. Klasse Color

"123"_km

123.3345_km

"10.11.33"_uhrzeit  ==> Objekt einer Klasse 

"DE80760501011234567890"_iban

Literale: Lexikon : Wörter , aus denen Sätze der Programmiersprache gebildet werden können

Sätze: Grammatik / Syntax

C++: Lexikon kann erweitert werden.

Wie:

a) operator ""    literal operator

b) Syntax:   operator ""  SUFFIX ( parameter )

unsigned long long
long double
const char*

C++  UDL  User Defined Literal

Call-to-Action: Welche technologischen Werte / Konstanten / Einheiten

==========================================================

Topic / Frage:

constexpr und throw:

a) Official Statement: In constexpr - Funktionen ist throw nicht erlaubt.

b) Duldung:

        if (value > 0xFFFFFF) {
            throw std::logic_error("literal too large");
        }


========================================================

Was ist das Problem mit new ????

Memory Leaks

delete wird nicht aufgerufen.

Lösungen:

Idee:

a) C++  // Objekt-orientierte Progr.Sprache

b) Konstruktoren / Destruktoren

c) Wann wird ein Destruktor aufgerufen ?

   Sobald das Objekt out-of-scope geht ! "}"

d) Beobachtung: Dies könnte man als deterministisch bezeichen.

e) Idee:

   Pointer (new) übergebe man in die Obhut einer Hüllenklasse

   i)  Konstruktor: Pointer an die Hüllenklasse übergeben kann
   ii) Destruktor:  Hier wird 'delete' aufgerufen

Fragen:  Lebt dann der Zeiger nur innerhalb eines Scopes ??? Nein.

auto_ptr:  deprecated.

std::unique_ptr
std::shared_ptr
std::weak_ptr

Strategien:

std::unique_ptr:

Dieser kann im Programm zu EINEM Zeitpunkt nur in den Händen
EINES Besitzers (Owner) sein.

std::shared_ptr:

Dieser kann im Programm zu EINEM Zeitpunkt in den Händen
MEHRERER Besitzer (Owner) sein.

std::weak_ptr:

Unterstützt den std::shared_ptr.

Dieser kann im Programm zu EINEM Zeitpunkt ein TEMPORÄRER Besitzer
eines Zeigers sein.

===============================================================

Frage: std::move(ptr) in KOMBINATION mit return;

    static std::unique_ptr<int> loadUniquePointer()
    {
        std::unique_ptr<int> ptr{ std::make_unique<int>(100) };
        return std::move(ptr);
    }

Schlechte Idee:

Don't do this: Bei 'return' hat der Compiler VIELE
Optimierungsmöglichkeiten.

Copy/Move Elision
RVO: Return Value Optimization
NRVO: Named Return Value Optimization

======================================================

Vorab:

Bisheriger Kenntnisstand:

Go-for Unique oder Shared Ptr

i)   Naheliegende Smart Pointer: Unique-Pointer  // Owner

     Weiterreichen: Verschiebens

ii)  Shared Ptr als Kandidat: Mehrere Besitzer. // Möglichst wenige wäre gut.

     Referenzzähler: 1 => 0

Problem:

     Der SharedPtr funktioniert nicht immer :(((((((

     Er gibt den Speicher nicht frei : Arghhhhhhhhhhhhhhh

a) Was ist das Problem?

b) Wie können wir es lösen?  std::weak_ptr

2 Vorträge:

i) Wie arbeitet die Klasse std::weak_ptr?

ii) Analyse / Behebung des Problems

======================================================

a) Was ist das Problem?

Zyklen.

Frage: Observer - Pattern

a) es gibt eine Quelle (Source).

   die hat Zustand (state), der sich ändert

b) es gibt Clients -- die sich für Änderungen des Zustands der Quelle interessieren.

c) der Client "meldet" sich an der Quelle an (register, attach, ..)

   // interface pointer

d) die Source "hebt diese Client (interface) zeiger" auf // Liste

Entscheidungen:

i) Quelle (Source): Owner ==> std::shared_ptr 

ii) Clients: Owner ==> std::shared_ptr 

iii) Wie sieht es mit der Liste der "Client (interface) Zeiger"
     in der Quelle aus ???

     std::list < shared > ???

     Soll tatsächlich eine Quelle , die mit Clients erst MAl nichts zu tun hat,
     zum "Owner" von Clients werden ????????????????????????

     Client nicht mehr notwendig ==> unregister / detach

    NEIN.        std::list < weak > ???

    Konsequenz: Es tritt in der Quelle eine Zustandsänderung ein:

    weak.lock();   ==> i) shared_ptr
                      ii) nullptr

    Loose Kopplung // keine: Strenge Kopplung


Ein Beispiel:

https://github.com/pelocpp/cpp_design_patterns/blob/master/Patterns/Observer/ConceptualExample02.cpp

https://stackoverflow.com/questions/10120623/removing-item-from-list-of-weak-ptrs


Fazit:

std::shared_ptr:  Okay , Owner

std::weak_ptr: So viel es geht verwenden.

Visualisierung:   std::weak_ptr:

Business Logik: Bauteile.

===================================================

Algorithmen:

Konkurrenz:   fort - Schleifen

Architektur:

Container:
std::vector                Iterator:                Algorithmus:

begin()                    <===>              std::find ( vec.begin(), vec.end()   )


Neu:

Range Based Loop:   for_each

std::vector<int> numbers;

for (  int elem  :  numbers ) {

}

============================================================

std::vector<int> :               HEAP


std::initializer_list<int>:      STACK

PERFORMANZ !!!!!!!!!!!!!!

Wehrmutstropfen



std::vector <int> vec (10);     // Size: 10 - Alle Elemente: 0

vs.

std::vector <int> vec { 10 };  // Size: 1 - Elemente: 10

======================================================

Hilfsklassen:

std::variant

Kann Werte unterschiedlichen Typs aufnehmen - zu einem Zeitpunkt
nur von einem Typ.

Excel // Google Sheets:   Zelle // Cell

Zelle:  Zeichenkette, Zahl , Datum, Währung ...

Die Typen müssen vorab bekannt sein !!!

C#  / Java:   Reflection

=============================================================

Aufgaben zu Smart Pointer:

   == Aufgabe 3

   == Aufgabe 1 (2)

=============================================================

Mittwoch früh:

a) Übung Shared-Ptr

Lambdas // std::bind

b) Frage zu delegate

Datei: "Frage_Delegates.cpp"

=============================================================

Variadische Templates:

a) Verstehen

b) Why !!!!!!!!!!!!!!!

c) Anwenden - kommt mit der Zeit

d) Berggipfel: Perfekt Forwarding.


Tool:  Cpp Insights

======================================================

Templates und Header Files:

Siehe hier:

Klassen Templates 

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/TemplateClassBasics/TemplatesClassBasics.md

==> Informationen zu den Übersetzungsmodellen für Templates.

Das Inclusion Modell   <==== ist am einfachsten

Das Explicit Instantiation Modell

======================================================

2 Funktionen

Pack und Komma Liste

Was ist ein Parameter Pack:

   printer(auto ... args);     

   printer(1, 2, 3, 4, 5);     

Zusammenfassung der Parameter // exakter: einer KOMMA-getrennten Liste von Werten
        unter einem Namen.

        Syntax:  ... args

Auspacken: ERZEUGEN einer KOMMA-getrennten Liste von Werten,
           die sich hinter einem Pack-Bezeichner befinden.

           Syntax:  args ... 



Why ????????????????????????

Transport von Daten:

== make_xxx Funktionen
== emplace ...
== Thread Prozeduren 

Packs und Initializer List

======================================================

Real Modern C++
---------------

======================================================

Klassisches Problem:

int n;

.....

if (n == 0)   // Gültiger Wert vorhanden ist ???

if (n == -1)   // Gültiger Wert vorhanden ist ???

if (n == std::npos)   // Gültiger Wert vorhanden ist ???


Saubere Lösung:

int  n;
bool isValid;

====> std::optional


VHIT  : Vom Hirn in die Tastatur

==============================================

 std::tuple: Erweiterung von std::pair

Wozu ist ein std::tuple ähnlich ???

Struktur für Schreibfaule

ZUsammen mit Structured Binding: Da bin ich von der Struktur nicht mehr weit entfernt !!!


std::variant <char, int, double> values;

    // Hier gibt es nur EINE Variable -- out of three (char, int, double)

versus

std::tuple <char, int, double> values;

    // Hier gibt es DREI Variablen -- char, int und double


std::variant:   

"Vektor von verschiedenen Elementen"

Hmmm: Gibt es einen Vektor von verschiedenen Elementen ???


Viele Ebenen

Daten wurden verdichtet / verändert und transportiert:

DTOs  // Data Transfer Objekt

Da könnte man auch std::tuple verwenden.


================================================

std::variant <char, int, double> values;

versus

std::any values;   // kann alles aufnehmen


CTAD  ==> Class Type Argument Deduction


Non-Owning Behaviour:

==============================================

SSO   Small String Optimization

std::string s ("ABC");

==============================================

Folding:    Abrollen

int result = 1 + 2 + 3 + 4 + 5 + 6 + 7;

Why ???????????????????  Performanz

printer (1, 2, 3)

( ... ,   ( std::cout << args << " - ") );

====>

( std::cout << 1 << " - ") ,  ( std::cout << 2 << " - ") ,  ( std::cout << 3 << " - ")

(( print (1) , print(2)  ) , print(3) )


( print (1) ,  (  print(2)   , print(3)  ))

45 Minuten

=============================================================

Aufgabe:

Aufgaben zu Folding:

Aufgabe 1: Logische Operationen mit beliebig vielen Operanden

true && true && true && true && true && true && true && true && true && true

===> Folding ???

==========================================================

Aufgaben zu Variadische Templates:

Aufgabe 2: decltype und Type-Traits am Beispiel von sameType

Vorausetzungen: std::is_same
